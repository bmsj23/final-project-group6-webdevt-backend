import mongoose from 'mongoose';

// message schema definition
const messageSchema = new mongoose.Schema(
  {
    conversationId: {
      type: String,
      required: false, // auto-generated by pre-save hook
      index: true,
    },

    sender: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: [true, 'Sender is required'],
      index: true,
    },

    recipient: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: [true, 'Recipient is required'],
      index: true,
    },

    product: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Product',
    },

    messageText: {
      type: String,
      required: false,
      maxlength: [1000, 'Message cannot exceed 1000 characters'],
      trim: true,
      validate: {
        validator: function() {
          return this.messageText || this.image || (this.images && this.images.length > 0);
        },
        message: 'Either message text or at least one image must be provided'
      }
    },

    image: {
      type: String,
      required: false,
    },

    images: {
      type: [String],
      default: [],
      validate: {
        validator: function(images) {
          return images.length <= 5;
        },
        message: 'Cannot send more than 5 images per message'
      }
    },

    isRead: {
      type: Boolean,
      default: false,
      index: true,
    },

    readAt: {
      type: Date,
    },

    createdAt: {
      type: Date,
      default: Date.now,
      index: true,
    },
  },
  {
    timestamps: false,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// compound indexes for faster queries
messageSchema.index({ conversationId: 1, createdAt: -1 });
messageSchema.index({ sender: 1, recipient: 1 });
messageSchema.index({ recipient: 1, isRead: 1 });

// static method to generate conversation id from two user ids
messageSchema.statics.generateConversationId = function(userId1, userId2) {

  const ids = [userId1.toString(), userId2.toString()].sort();  // sort user ids to ensure consistent conversation id
  return `${ids[0]}_${ids[1]}`;
};

// middleware to generate conversation id before saving
messageSchema.pre('save', function(next) {
  if (this.isNew && !this.conversationId) {
    this.conversationId = this.constructor.generateConversationId(
      this.sender,
      this.recipient
    );
  }
  next();
});

// instance method: mark message as read
messageSchema.methods.markAsRead = function() {
  if (!this.isRead) {
    this.isRead = true;
    this.readAt = new Date();
    return this.save();
  }
  return Promise.resolve(this);
};

// static method: get conversation between two users
messageSchema.statics.getConversation = function(userId1, userId2, options = {}) {
  const conversationId = this.generateConversationId(userId1, userId2);
  const { limit = 50, skip = 0 } = options;

  return this.find({ conversationId })
    .sort({ createdAt: -1 })
    .limit(limit)
    .skip(skip)
    .populate('sender', 'name profilePicture')
    .populate('recipient', 'name profilePicture')
    .populate('product', 'title images price');
};

// static method: get all conversations for a user
messageSchema.statics.getUserConversations = async function(userId) {

    // get unique conversation ids where user is sender or recipient
  const conversations = await this.aggregate([
    {
      $match: {
        $or: [
          { sender: new mongoose.Types.ObjectId(userId) },
          { recipient: new mongoose.Types.ObjectId(userId) },
        ],
      },
    },
    {
      $sort: { createdAt: -1 },
    },
    {
      $group: {
        _id: '$conversationId',
        lastMessage: { $first: '$$ROOT' },
        unreadCount: {
          $sum: {
            $cond: [
              {
                $and: [
                  { $eq: ['$recipient', new mongoose.Types.ObjectId(userId)] },
                  { $eq: ['$isRead', false] },
                ],
              },
              1,
              0,
            ],
          },
        },
      },
    },
    {
      $sort: { 'lastMessage.createdAt': -1 },
    },
  ]);

  // populate user details
  await this.populate(conversations, {
    path: 'lastMessage.sender lastMessage.recipient',
    select: 'name profilePicture',
  });

  return conversations;
};

// static method: mark all messages as read in a conversation
messageSchema.statics.markConversationAsRead = async function(conversationId, recipientId) {
  // first, get the IDs of messages that will be marked as read
  const messagesToUpdate = await this.find(
    {
      conversationId,
      recipient: recipientId,
      isRead: false,
    },
    { _id: 1 }
  );

  const messageIds = messagesToUpdate.map(msg => msg._id.toString());

  // then update them
  await this.updateMany(
    {
      conversationId,
      recipient: recipientId,
      isRead: false,
    },
    {
      $set: {
        isRead: true,
        readAt: new Date(),
      },
    }
  );

  return messageIds;
};

// static method: get unread message count for user
messageSchema.statics.getUnreadCount = function(userId) {
  return this.countDocuments({
    recipient: userId,
    isRead: false,
  });
};

// static method: delete conversation
messageSchema.statics.deleteConversation = function(userId1, userId2) {
  const conversationId = this.generateConversationId(userId1, userId2);
  return this.deleteMany({ conversationId });
};

const Message = mongoose.models.Message || mongoose.model('Message', messageSchema);

export default Message;